% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Algorithms_assessment.R
\name{Getting_Asses_results}
\alias{Getting_Asses_results}
\title{Get the result of function Assessment_via_cluster}
\usage{
Getting_Asses_results(
  sample.size,
  replace = FALSE,
  pred,
  meas,
  memb,
  metrics_used = 1,
  cluster = apply(memb, 1, which.max),
  seed = NULL,
  log10 = TRUE,
  valid.definition = list(negative = FALSE, percent = 0.6)
)
}
\arguments{
\item{sample.size}{Sample size. This supports a bootstrap way to run the function 
\link{Assessment_via_cluster}. The number should not be larger than the row number 
of pred or so.}

\item{replace}{Logical, replace, default as \code{FALSE}}

\item{pred}{Prediction matrix or data.frame}

\item{meas}{Measured (actual) matrix or data.frame}

\item{memb}{Membership matrix}

\item{metrics_used}{The metric combination used in the function. Default is \code{1}.

If \code{metrics_used = 1} then the used metrics are \code{c("MAE", "CMAPE", "BIAS", "CMRPE")}

If \code{metrics_used = 2} then the used metrics are \code{c("MAE", "CMAPE", "BIAS", "CMRPE", "RATIO")}}

\item{cluster}{Cluster vector. Could be calculated by the parameter \code{memb}. Will be deprecated later.}

\item{seed}{Seed number for fixing the random process. See \code{help(set.seed)} for more details.}

\item{log10}{pass to \link{Sampling_by_sort}.}

\item{valid.definition}{The definition of valid prediction, default as \code{list(negative=FALSE, percent = 0.6)}.
  The invalid prediction will not be removed to calculate error metrics.

\code{negative=FALSE} means the negative values are considered as invalid predictions while \code{percent} means
  the tolerance of error-percentage that only the predictions between \code{(y-y*percent), y+y*percent)} are valid.}
}
\value{
A list containing fuzzy and hard results from \link{Assessment_via_cluster}
}
\description{
This function mainly use function \link{Assessment_via_cluster} to get
  assessments both from fuzzy and hard mode. Specifically, it will return the accuracy and precision of 
  \code{MAE},\code{CMAPE},\code{BIAS}, and \code{CMRPE} which would be seemed as the input value of 
  function \link{Scoring_system}.
}
\note{
The row number of \code{pred}, \code{meas}, \code{memb}, and \code{cluster} should be the same. 
  This function is designed for bootstrapping process to get Chla algorithms assessment. Therefore, 
  parameters of \link{Assessment_via_cluster} is set as fixed such as \code{log10 = TRUE}, 
  \code{na.process = TRUE}. Given that, I will not export this function in latter to avoid confuses.
}
\examples{
library(FCMm) 
library(ggplot2) 
library(magrittr)
library(stringr)
data("Nechad2015")
x <- Nechad2015[,3:11]
wv <- gsub("X","",names(x)) \%>\% as.numeric
set.seed(1234)
w <- sample.int(nrow(x), 300)
x <- x[w, ]
names(x) <- wv
nb = 4 # Obtained from the vignette "Cluster a new dataset by FCMm"
set.seed(1234)
FD <- FuzzifierDetermination(x, wv, do.stand=TRUE)
result <- FCM.new(FD, nb, fast.mode = TRUE)
p.spec <- plot_spec(result, show.stand=TRUE)
print(p.spec$p.cluster.spec)
Chla <- Nechad2015$X.Chl_a..ug.L.[w]
Chla[Chla >= 999] <- NA
dt_Chla <- run_all_Chla_algorithms(x) \%>\% as.data.frame
dt_Chla <- data.frame(Chla_true = Chla,
BR_Gil10 = dt_Chla$BR_Gil10, 
OC4_OLCI = dt_Chla$OC4_OLCI, 
OCI_Hu12 = dt_Chla$OCI_Hu12, 
NDCI_Mi12= dt_Chla$NDCI_Mi12) \%>\% round(3)
w = which(!is.na(dt_Chla$Chla_true))
dt_Chla = dt_Chla[w,]
memb = result$res.FCM$u[w,] \%>\% round(4)
cluster =  result$res.FCM$cluster[w]
Asses_results <- Getting_Asses_results(sample.size=length(cluster), 
pred = dt_Chla[,-1], meas = data.frame(dt_Chla[,1]), memb = memb, 
cluster = cluster)

}
\seealso{
Other Algorithm assessment: 
\code{\link{Assessment_via_cluster}()},
\code{\link{Sampling_via_cluster}()},
\code{\link{Score_algorithms_interval}()},
\code{\link{Score_algorithms_sort}()},
\code{\link{Scoring_system}()}
}
\concept{Algorithm assessment}
